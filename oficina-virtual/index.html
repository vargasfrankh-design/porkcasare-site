<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Oficina Virtual - PorkCasare</title>
  <link rel="stylesheet" href="css/style.css" />
<style>
/* Loading overlay styles */
#page-loading-overlay {
  position: fixed;
  inset: 0;
  background: linear-gradient(180deg, rgba(10,11,13,0.65), rgba(20,22,23,0.65));
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 99999;
  opacity: 1;
  transition: opacity 300ms ease, visibility 300ms ease;
  visibility: visible;
  backdrop-filter: blur(4px) saturate(120%);
  -webkit-backdrop-filter: blur(4px) saturate(120%);
}

/* Hidden state */
#page-loading-overlay.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* Card */
#page-loading-overlay .loader-card {
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
  border-radius: 14px;
  padding: 22px 28px;
  display: flex;
  gap: 16px;
  align-items: center;
  box-shadow: 0 6px 30px rgba(2,6,23,0.6);
  border: 1px solid rgba(255,255,255,0.06);
  color: #fff;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}

/* Spinner */
.loader-spinner {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  display: grid;
  place-items: center;
  background: conic-gradient(from 0deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
  padding: 6px;
  box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25);
}
.loader-spinner .dot {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: 4px solid transparent;
  border-top-color: #7be495;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Text */
.loader-text {
  display: flex;
  flex-direction: column;
}
.loader-text .title {
  font-weight: 700;
  font-size: 16px;
  letter-spacing: 0.1px;
}
.loader-text .subtitle {
  margin-top: 4px;
  font-size: 13px;
  color: rgba(255,255,255,0.85);
}

/* subtle pulse under the card */
#page-loading-overlay::after {
  content: "";
  position: absolute;
  width: 220px;
  height: 220px;
  border-radius: 50%;
  background: radial-gradient(circle at center, rgba(123,228,149,0.12), transparent 40%);
  filter: blur(12px);
  z-index: 99998;
  transform: translateY(40px);
}
</style>
</head>
<body>

<!-- Enhanced Loading overlay control â€” robust with error-handling and diagnostics -->
<script>
(function () {
  const overlayId = 'page-loading-overlay';
  const overlay = document.getElementById(overlayId);

  function logDebug(...args){ try{ console.debug('[page-loading]', ...args); }catch(e){} }

  window.showPageLoading = function(message) {
    if (!overlay) return;
    overlay.classList.remove('hidden');
    overlay.setAttribute('aria-hidden', 'false');
    if (message) {
      const sub = overlay.querySelector('.loader-text .subtitle');
      if (sub) sub.textContent = message;
    }
  };

  window.hidePageLoading = function() {
    if (!overlay) return;
    overlay.classList.add('hidden');
    overlay.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    }, 400);
  };

  function isProfileUsingDefault(imgEl) {
    try {
      if (!imgEl) return true;
      const raw = imgEl.getAttribute && imgEl.getAttribute('src') ? imgEl.getAttribute('src') : (imgEl.src || '');
      const src = String(raw).split('?')[0].toLowerCase();
      if (!src) return true;
      if (src.indexOf('default-avatar') !== -1) return true;
      if (src.match(/avatar[_-]?\d+\.png$/)) return true;
      if (src.indexOf('/images/avatars/') !== -1 && src.match(/avatar\d+\.png$/)) return true;
      return false;
    } catch (e) {
      return true;
    }
  }

  // Track if any JS runtime error occurred (uncaught)
  let runtimeErrorOccured = false;
  window.addEventListener('error', function(e){ runtimeErrorOccured = true; logDebug('runtime error event', e && e.message); });
  window.addEventListener('unhandledrejection', function(e){ runtimeErrorOccured = true; logDebug('unhandled rejection', e && e.reason); });

  function safeHide() {
    try {
      if (typeof window.hidePageLoading === 'function') {
        window.hidePageLoading();
      } else {
        const ov = document.getElementById(overlayId);
        if (ov) ov.classList.add('hidden');
      }
    } catch (e) {
      const ov = document.getElementById(overlayId);
      if (ov) ov.classList.add('hidden');
    }
  }

  function waitForAvatarGridThenHide(options) {
    options = options || {};
    const avatarGrid = document.querySelector('.avatar-grid') || document.getElementById('avatarGrid');
    const profileImg = document.getElementById('profileImg');
    const changeAvatarBtn = document.getElementById('changeAvatarBtn');
    logDebug('waitForAvatarGridThenHide: found avatarGrid, profileImg', !!avatarGrid, !!profileImg);

    if (!avatarGrid) {
      logDebug('no avatarGrid -> hide soon');
      setTimeout(safeHide, 120);
      return;
    }

    // If profile uses default, hide quickly
    if (isProfileUsingDefault(profileImg)) {
      logDebug('profile uses default -> hide soon');
      setTimeout(safeHide, 120);
      return;
    }

    // If a runtime error occurred, avoid blocking
    if (runtimeErrorOccured) {
      logDebug('runtime error detected -> hiding overlay to avoid lock');
      setTimeout(safeHide, 120);
      return;
    }

    // Observe removal or style changes on avatarGrid
    let observer = null;
    let finished = false;
    const finish = () => {
      if (finished) return;
      finished = true;
      try { if (observer) observer.disconnect(); } catch(e){}
      safeHide();
    };

    try {
      observer = new MutationObserver(() => {
        try {
          const inDom = document.body.contains(avatarGrid);
          const style = window.getComputedStyle(avatarGrid);
          const isHidden = !inDom || (style && (style.display === 'none' || style.visibility === 'hidden' || avatarGrid.hidden));
          logDebug('observer sees isHidden=', isHidden);
          if (isHidden) finish();
        } catch (err) {
          logDebug('observer callback error', err);
        }
      });
      observer.observe(avatarGrid, { attributes: true, attributeFilter: ['style','class','hidden'], childList: true, subtree: false });
    } catch (e) {
      logDebug('observer attach failed', e);
      observer = null;
    }

    // Polling fallback with limited attempts
    let attempts = 0;
    const maxAttempts = options.maxAttempts || 60; // 60 * 250ms ~= 15s
    const pollInterval = options.pollInterval || 250;
    const poll = setInterval(() => {
      attempts++;
      try {
        const inDom = document.body.contains(avatarGrid);
        const style = window.getComputedStyle(avatarGrid);
        const isHidden = !inDom || (style && (style.display === 'none' || style.visibility === 'hidden' || avatarGrid.hidden));
        logDebug('poll attempt', attempts, 'isHidden', isHidden);
        if (isHidden) {
          clearInterval(poll);
          finish();
          return;
        }
        if (runtimeErrorOccured) {
          clearInterval(poll);
          logDebug('runtime error during polling');
          finish();
          return;
        }
        if (attempts >= maxAttempts) {
          clearInterval(poll);
          logDebug('max attempts reached -> finishing to avoid lock');
          finish();
          return;
        }
      } catch (e) {
        clearInterval(poll);
        finish();
      }
    }, pollInterval);

    // Also detect clicks on changeAvatarBtn which probably triggers the hide
    if (changeAvatarBtn) {
      changeAvatarBtn.addEventListener('click', () => {
        setTimeout(() => {
          try {
            const style = window.getComputedStyle(avatarGrid);
            if (style.display === 'none' || avatarGrid.hidden) finish();
          } catch (e) { finish(); }
        }, 220);
      });
    }

    // Safety timeout: hide after 18 seconds regardless
    setTimeout(() => {
      if (!finished) {
        logDebug('safety timeout triggered -> hiding overlay');
        finish();
      }
    }, 18000);
  }

  // Main hook: run on load
  window.addEventListener('load', () => {
    try {
      const avatarGrid = document.querySelector('.avatar-grid') || document.getElementById('avatarGrid');
      const profileImg = document.getElementById('profileImg');
      logDebug('onload: avatarGrid?', !!avatarGrid, 'profileImg default?', isProfileUsingDefault(profileImg));
      if (!avatarGrid || isProfileUsingDefault(profileImg) || runtimeErrorOccured) {
        setTimeout(safeHide, 260);
      } else {
        waitForAvatarGridThenHide({ maxAttempts: 60, pollInterval: 250 });
      }
    } catch (e) {
      // fallback hide
      safeHide();
    }
  });

  // expose manual hook
  window.onMapReady = function(){ safeHide(); };
  window.__pageLoadingDebug = { isProfileUsingDefault };

  // Also, if overlay exists but nothing happens, allow manual hide via console: window.hidePageLoading()
})();
</script>



</body>
</html>
